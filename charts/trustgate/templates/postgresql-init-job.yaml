{{- /*
Job to initialize TrustGate PostgreSQL database and user.
1) First tries to connect using trustgate-secrets (DATABASE_HOST, DATABASE_USER, DATABASE_PASSWORD).
   If successful, the user and database already exist – job exits successfully.
2) If that fails, creates the user/database using postgresql-secrets (admin credentials), when
   postgres is deployed in-cluster. postgresql-secrets is optional when using external PostgreSQL.
*/}}
{{- $pgSecretName := "postgresql-secrets" }}
{{- $tgSecretName := "trustgate-secrets" }}
{{- /* Get database values from trustgate.global.env; defaults: port 5432, database/name trustgate, user trustgate */}}
{{- $tgDbHost := "" }}
{{- $tgDbPort := "5432" }}
{{- $tgDbUser := "trustgate" }}
{{- $tgDbPassword := "" }}
{{- $tgDbName := "trustgate" }}
{{- $tgDbSslMode := "require" }}
{{- if and .Values.global.env .Values.global.env.DATABASE_HOST (ne .Values.global.env.DATABASE_HOST "") }}
  {{- $tgDbHost = .Values.global.env.DATABASE_HOST }}
{{- end }}
{{- if and .Values.global.env .Values.global.env.DATABASE_PORT (ne .Values.global.env.DATABASE_PORT "") }}
  {{- $tgDbPort = .Values.global.env.DATABASE_PORT | toString }}
{{- end }}
{{- if and .Values.global.env .Values.global.env.DATABASE_USER (ne .Values.global.env.DATABASE_USER "") }}
  {{- $tgDbUser = .Values.global.env.DATABASE_USER }}
{{- end }}
{{- if and .Values.global.env .Values.global.env.DATABASE_PASSWORD (ne .Values.global.env.DATABASE_PASSWORD "") }}
  {{- $tgDbPassword = .Values.global.env.DATABASE_PASSWORD }}
{{- end }}
{{- if and .Values.global.env .Values.global.env.DATABASE_NAME (ne .Values.global.env.DATABASE_NAME "") }}
  {{- $tgDbName = .Values.global.env.DATABASE_NAME }}
{{- end }}
{{- if and .Values.global.env .Values.global.env.DATABASE_SSL_MODE (ne .Values.global.env.DATABASE_SSL_MODE "") }}
  {{- $tgDbSslMode = .Values.global.env.DATABASE_SSL_MODE }}
{{- end }}
{{- /* Check if parent chart handles secret auto-generation */}}
{{- $autoGenerate := false }}
{{- if and .Values.global (hasKey .Values.global "autoGenerateSecrets") .Values.global.autoGenerateSecrets }}
  {{- $autoGenerate = true }}
{{- end }}
{{- /* Create job if we have the required values OR if autoGenerateSecrets is enabled */}}
{{- /* When autoGenerate is true, the parent chart creates trustgate-secrets with the password */}}
{{- if or (and $tgDbHost $tgDbPassword $tgDbName $tgDbUser) (and $autoGenerate $tgDbHost) }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "trustgate.fullname" . }}-postgresql-init
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "trustgate.labels" . | nindent 4 }}
    app.kubernetes.io/component: postgresql-init
spec:
  backoffLimit: 3
  ttlSecondsAfterFinished: 600
  template:
    metadata:
      labels:
        {{- include "trustgate.labels" . | nindent 8 }}
        app.kubernetes.io/component: postgresql-init
    spec:
      restartPolicy: Never
      containers:
      - name: postgresql-init
        {{- $postgresImageRepo := "postgres" }}
        {{- $postgresImageTag := "17.2-alpine" }}
        {{- if and .Values.global .Values.global.postgresql .Values.global.postgresql.image }}
          {{- if .Values.global.postgresql.image.repository }}
            {{- $postgresImageRepo = .Values.global.postgresql.image.repository }}
          {{- end }}
          {{- if .Values.global.postgresql.image.tag }}
            {{- $postgresImageTag = .Values.global.postgresql.image.tag }}
          {{- end }}
        {{- end }}
        {{- $postgresImage := printf "%s:%s" $postgresImageRepo $postgresImageTag }}
        {{- if and .Values.global .Values.global.imageRegistry .Values.global.imageRegistry }}
          {{- $registry := .Values.global.imageRegistry }}
          {{- if hasPrefix $registry $postgresImageRepo }}
            {{- $postgresImage = printf "%s:%s" $postgresImageRepo $postgresImageTag }}
          {{- else }}
            {{- $postgresImage = printf "%s/%s:%s" $registry $postgresImageRepo $postgresImageTag }}
          {{- end }}
        {{- end }}
        image: {{ $postgresImage | quote }}
        command:
        - /bin/sh
        - -c
        - |
          set -e
          
          # Get TrustGate database and user from trustgate-secrets (defaults: name=trustgate, user=trustgate, port=5432)
          TG_DB_NAME="${TG_DATABASE_NAME:-trustgate}"
          TG_DB_USER="${TG_DATABASE_USER:-trustgate}"
          TG_DB_PORT="${TG_DATABASE_PORT:-5432}"
          TG_DB_PASSWORD="${TG_DATABASE_PASSWORD}"
          
          # Determine SSL mode for connection
          PG_SSL_MODE="${POSTGRES_SSL_MODE:-disable}"
          
          # Wait for trustgate-secrets to exist and have required values
          echo "Waiting for trustgate-secrets to be available..."
          SECRET_MAX_ATTEMPTS=60
          SECRET_ATTEMPT=0
          
          while [ $SECRET_ATTEMPT -lt $SECRET_MAX_ATTEMPTS ]; do
            if [ -n "${TG_DATABASE_PASSWORD}" ]; then
              echo "✓ trustgate-secrets values loaded successfully"
              break
            fi
            
            SECRET_ATTEMPT=$((SECRET_ATTEMPT + 1))
            if [ $((SECRET_ATTEMPT % 5)) -eq 0 ]; then
              echo "Attempt $SECRET_ATTEMPT/$SECRET_MAX_ATTEMPTS: Waiting for trustgate-secrets..."
              echo "  Missing:"
              [ -z "${TG_DATABASE_PASSWORD}" ] && echo "    - TG_DATABASE_PASSWORD (DATABASE_PASSWORD)"
            fi
            sleep 2
          done
          
          if [ -z "${TG_DATABASE_PASSWORD}" ]; then
            echo "ERROR: trustgate-secrets not found or incomplete after $((SECRET_MAX_ATTEMPTS * 2)) seconds."
            echo "Missing values:"
            [ -z "${TG_DATABASE_HOST}" ] && echo "  - TG_DATABASE_HOST (DATABASE_HOST)"
            [ -z "${TG_DATABASE_NAME}" ] && echo "  - TG_DATABASE_NAME (DATABASE_NAME)"
            [ -z "${TG_DATABASE_USER}" ] && echo "  - TG_DATABASE_USER (DATABASE_USER)"
            [ -z "${TG_DATABASE_PASSWORD}" ] && echo "  - TG_DATABASE_PASSWORD (DATABASE_PASSWORD)"
            echo ""
            echo "Ensure the following are set in values.yaml:"
            echo "  trustgate.global.env.DATABASE_HOST"
            echo "  trustgate.global.env.DATABASE_PASSWORD"
            echo "  trustgate.global.env.DATABASE_NAME (optional, defaults to 'trustgate')"
            echo "  trustgate.global.env.DATABASE_USER (optional, defaults to 'trustgate')"
            echo ""
            echo "The trustgate-secrets will be created automatically if DATABASE_HOST and DATABASE_PASSWORD are set."
            exit 1
          fi
          
          # Export SSL mode for psql (used for both trustgate and admin connections)
          if [ "${PG_SSL_MODE}" != "disable" ]; then
            export PGSSLMODE="${PG_SSL_MODE}"
          fi
          
          # First try to connect using TrustGate credentials (trustgate-secrets).
          # If successful, the user and database already exist – we are done.
          echo "Trying to connect using TrustGate credentials at ${TG_DATABASE_HOST}:${TG_DB_PORT}..."
          TRY_MAX=10
          TRY_N=0
          while [ $TRY_N -lt $TRY_MAX ]; do
            if PGPASSWORD="${TG_DATABASE_PASSWORD}" psql -h "${TG_DATABASE_HOST}" -p "${TG_DB_PORT}" -U "${TG_DB_USER}" -d "${TG_DB_NAME}" -c "SELECT 1" 2>/dev/null; then
              echo "✓ Connected with TrustGate credentials; user and database already exist."
              exit 0
            fi
            TRY_N=$((TRY_N + 1))
            if [ $((TRY_N % 10)) -eq 0 ] && [ $TRY_N -gt 0 ]; then
              echo "Attempt $TRY_N/$TRY_MAX: TrustGate connection not successful yet, retrying..."
            fi
            sleep 2
          done
          
          echo "Could not connect with TrustGate credentials after $TRY_MAX attempts. Will try to create user/database using admin credentials if available."
          
          # Admin credentials (postgresql-secrets) are required to create user/database.
          # They are optional when using external PostgreSQL – in that case create the trustgate user and database beforehand.
          if [ -z "${POSTGRES_HOST}" ] || [ -z "${POSTGRES_USER}" ] || [ -z "${POSTGRES_PASSWORD}" ]; then
            echo "ERROR: Could not connect with TrustGate credentials and admin credentials (postgresql-secrets) are not available."
            echo "When using external PostgreSQL, create the trustgate user and database beforehand."
            exit 1
          fi
          
          # Get PostgreSQL admin credentials from postgresql-secrets (for create path)
          PG_HOST="${POSTGRES_HOST}"
          PG_PORT="${POSTGRES_PORT:-5432}"
          PG_ADMIN_USER="${POSTGRES_USER}"
          PG_ADMIN_PASSWORD="${POSTGRES_PASSWORD}"
          
          # Wait for PostgreSQL to be ready before attempting initialization
          echo "Waiting for PostgreSQL to be ready at ${PG_HOST}:${PG_PORT}..."
          MAX_ATTEMPTS=240
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            # First check if the service endpoint is accessible
            if nc -z -w 2 "${PG_HOST}" "${PG_PORT}" 2>/dev/null; then
              echo "PostgreSQL service is accessible, verifying database is ready..."
              
              # Export PGPASSWORD for pg_isready
              export PGPASSWORD="${PG_ADMIN_PASSWORD}"
              
              # Try to connect to PostgreSQL using pg_isready
              # pg_isready checks if PostgreSQL is accepting connections
              if pg_isready -h "${PG_HOST}" -p "${PG_PORT}" -U "${PG_ADMIN_USER}" -t 2 >/dev/null 2>&1; then
                echo "✓ PostgreSQL is ready and accepting connections!"
                break
              else
                echo "PostgreSQL port is open but not ready yet, waiting..."
              fi
            else
              echo "PostgreSQL service not accessible yet, waiting..."
            fi
            
            ATTEMPT=$((ATTEMPT + 1))
            if [ $((ATTEMPT % 10)) -eq 0 ]; then
              echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: PostgreSQL not ready yet, waiting..."
            fi
            sleep 2
          done
          
          if [ $ATTEMPT -ge $MAX_ATTEMPTS ]; then
            echo "ERROR: PostgreSQL did not become ready at ${PG_HOST}:${PG_PORT} within $((MAX_ATTEMPTS * 2)) seconds."
            echo "Check PostgreSQL pod logs and status for more information."
            exit 1
          fi
          
          # Build psql connection options (PGSSLMODE already exported above if not disable)
          PSQL_OPTS="-h ${PG_HOST} -p ${PG_PORT} -U ${PG_ADMIN_USER}"
          
          echo "Connecting to PostgreSQL at ${PG_HOST}:${PG_PORT} as ${PG_ADMIN_USER} (SSL mode: ${PG_SSL_MODE})"
          echo "Creating database '${TG_DB_NAME}' and user '${TG_DB_USER}' if they don't exist..."
          
          # Export PGPASSWORD for psql
          export PGPASSWORD="${PG_ADMIN_PASSWORD}"
          
          # Create user if it doesn't exist
          echo "Checking if user '${TG_DB_USER}' exists..."
          USER_EXISTS=$(psql ${PSQL_OPTS} -d postgres -tAc "SELECT 1 FROM pg_roles WHERE rolname='${TG_DB_USER}'" 2>/dev/null || echo "0")
          
          if [ "${USER_EXISTS}" != "1" ]; then
            echo "Creating user '${TG_DB_USER}'..."
            psql ${PSQL_OPTS} -d postgres -c "CREATE USER \"${TG_DB_USER}\" WITH PASSWORD '${TG_DB_PASSWORD}';" || {
              echo "ERROR: Failed to create user '${TG_DB_USER}'"
              exit 1
            }
            echo "User '${TG_DB_USER}' created successfully"
          else
            echo "User '${TG_DB_USER}' already exists, updating password..."
            psql ${PSQL_OPTS} -d postgres -c "ALTER USER \"${TG_DB_USER}\" WITH PASSWORD '${TG_DB_PASSWORD}';" || {
              echo "WARNING: Failed to update password for user '${TG_DB_USER}'"
            }
          fi
          
          # Create database if it doesn't exist
          echo "Checking if database '${TG_DB_NAME}' exists..."
          DB_EXISTS=$(psql ${PSQL_OPTS} -d postgres -tAc "SELECT 1 FROM pg_database WHERE datname='${TG_DB_NAME}'" 2>/dev/null || echo "0")
          
          if [ "${DB_EXISTS}" != "1" ]; then
            echo "Creating database '${TG_DB_NAME}'..."
            psql ${PSQL_OPTS} -d postgres -c "CREATE DATABASE \"${TG_DB_NAME}\" OWNER \"${TG_DB_USER}\";" || {
              echo "ERROR: Failed to create database '${TG_DB_NAME}'"
              exit 1
            }
            echo "Database '${TG_DB_NAME}' created successfully"
          else
            echo "Database '${TG_DB_NAME}' already exists"
          fi
          
          # Grant all privileges on the database to the user
          echo "Granting privileges on database '${TG_DB_NAME}' to user '${TG_DB_USER}'..."
          psql ${PSQL_OPTS} -d postgres -c "GRANT ALL PRIVILEGES ON DATABASE \"${TG_DB_NAME}\" TO \"${TG_DB_USER}\";" || {
            echo "WARNING: Failed to grant privileges"
          }
          
          # Grant schema privileges (for PostgreSQL 15+)
          echo "Granting schema privileges..."
          psql ${PSQL_OPTS} -d "${TG_DB_NAME}" -c "GRANT ALL ON SCHEMA public TO \"${TG_DB_USER}\";" || {
            echo "WARNING: Failed to grant schema privileges"
          }
          
          echo "PostgreSQL initialization completed successfully!"
        resources:
          {{- $pgInit := index .Values "postgresqlInit" }}
          {{- if and $pgInit (index $pgInit "resources") }}
          {{- toYaml (index $pgInit "resources") | nindent 10 }}
          {{- else }}
          requests:
            cpu: 250m
            memory: 64Mi
          limits:
            cpu: 500m
            memory: 128Mi
          {{- end }}
        env:
        # PostgreSQL admin credentials from postgresql-secrets (optional when using external PostgreSQL)
        - name: POSTGRES_HOST
          valueFrom:
            secretKeyRef:
              name: {{ $pgSecretName }}
              key: POSTGRES_HOST
              optional: true
        - name: POSTGRES_PORT
          valueFrom:
            secretKeyRef:
              name: {{ $pgSecretName }}
              key: POSTGRES_PORT
              optional: true
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: {{ $pgSecretName }}
              key: POSTGRES_USER
              optional: true
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: {{ $pgSecretName }}
              key: POSTGRES_PASSWORD
              optional: true
        # TrustGate database and user from trustgate-secrets (used for "try trustgate first" and for create)
        - name: TG_DATABASE_HOST
          valueFrom:
            secretKeyRef:
              name: {{ $tgSecretName }}
              key: DATABASE_HOST
              optional: true
        - name: TG_DATABASE_PORT
          valueFrom:
            secretKeyRef:
              name: {{ $tgSecretName }}
              key: DATABASE_PORT
              optional: true
        - name: TG_DATABASE_NAME
          valueFrom:
            secretKeyRef:
              name: {{ $tgSecretName }}
              key: DATABASE_NAME
              optional: true
        - name: TG_DATABASE_USER
          valueFrom:
            secretKeyRef:
              name: {{ $tgSecretName }}
              key: DATABASE_USER
              optional: true
        - name: TG_DATABASE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: {{ $tgSecretName }}
              key: DATABASE_PASSWORD
        # SSL mode (check if in-cluster PostgreSQL)
        - name: POSTGRES_SSL_MODE
          value: {{ $tgDbSslMode }}
{{- end }}

